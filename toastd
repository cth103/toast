#!/usr/bin/python
#
#    Copyright (C) 2014-2017 Carl Hetherington <cth@carlh.net>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

have_gpio = True
try:
    import RPi.GPIO
except:
    have_gpio = False

import BaseHTTPServer
import threading
import json
import time
import os
import sys
import datetime
import socket
import argparse
import urlparse
import traceback

import json_server
import util

# GPIO pin of boiler relay
BOILER_GPIO = 2
# Hysteresis in degrees
HYSTERESIS = 0.2
# Interval in seconds to check state and update hardware
CHECK_INTERVAL = 1
# Minutes to keep temperatures in memory
MEMORY_LOG_MINUTES = 60 * 24 * 7
# Hours of the day to turn off heating automatically in
# case somebody has forgotten
AUTO_OFF_HOURS = [0, 1, 2, 3, 4, 5, 6, 10]
# Default target temperature
DEFAULT_TARGET = 19.0
# Port to talk to zones on
ZONE_PORT = 9142
# Port to listen for ESP8266 UDP broadcasts
BROADCAST_PORT = 9143
# MAC addresses of zones with names
zone_names = { '600194189ed3': 'Bathroom' }

class Zone(object):
    """
    Representation of a heating zone.  Used to keep track of the zones
    in the system (their names and ip addresses etc.) and to communicate
    with the zone servers.
    """
    def __init__(self, name, ip, port=ZONE_PORT):
        self.name = name
        self.ip = ip
        self.port = port
        self.radiator_on = False

    def __str__(self):
        return self.name

    def __eq__(self, other):
        if other is None:
            return False

        return self.name == other.name

    def __hash__(self):
        return hash(self.name)

    def connect(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect((self.ip, self.port))
        return s

    def set_radiator_on(self, on):
        """Tell the zone to turn its radiator on or off"""
        pass

    def get_temperature(self):
        """Ask the zone what its current temperature is"""
        pass

class JSONZone(Zone):
    def set_radiator_on(self, on):
        if on == self.radiator_on:
            return
        s = self.connect()
        util.send_json(s, {'type': 'set', 'radiator_on': on})
        self.radiator_on = on

    def get_temperature(self):
        util.verbose("Connecting for temperature of %s" % self.name)
        s = self.connect()
        util.send_json(s, {'type': 'get'})
        j = util.receive_json(s)['temperature']
        util.verbose("Received temperature %f of %s" % (j, self.name))
        return j

class ESP8266Zone(Zone):
    def __init__(self, ip, mac):
        if mac in zone_names:
            name = zone_names[mac]
        else:
            name = 'Unknown'
        super(ESP8266Zone, self).__init__(name, ip, ZONE_PORT)
        self.mac = mac
        self.lock = threading.Lock()

    def set_radiator_on(self, on):
        if on == self.radiator_on:
            return
        try:
            self.lock.acquire()
            s = self.connect()
            if on:
                s.send('on')
            else:
                s.send('off')
            s.close()
        finally:
            self.lock.release()

        self.radiator_on = on

    def get_temperature(self):
        try:
            self.lock.acquire()
            util.verbose("Connecting for temperature of %s" % self.name)
            s = self.connect()
            s.send('temp')
            r = int(s.recv(64)) / 10000.0
            util.verbose("Received temperature %f of %s" % (r, self.name))
            s.close()
            return r
        finally:
            self.lock.release()

FIXED_ZONES = []
FIXED_ZONES.append(JSONZone('Sitting room', 'localhost'))

dynamic_zones = []
dynamic_zones_mutex = threading.Lock()

def zones():
    global FIXED_ZONES
    global dynamic_zones
    return FIXED_ZONES + dynamic_zones

# True to stop all threads
stop = False
# Server which talks to clients
server = None
# True to write logs, false if not
write_logs = True
# Condition variable which when notified will cause
# an update of our state
update_condition = threading.Condition()

def request_update():
    global update_condition
    update_condition.acquire()
    update_condition.notify()
    update_condition.release()

def zone_by_name(name):
    """Return the zone object which has a particular name"""
    for z in zones():
        if z.name == name:
            return z

    return None

class Rule:
    """Specification of a target to aim for in a particular zone during a particular time range"""
    MONDAY = 1 << 0
    TUESDAY = 1 << 1
    WEDNESDAY = 1 << 2
    THURSDAY = 1 << 3
    FRIDAY = 1 << 4
    SATURDAY = 1 << 5
    SUNDAY = 1 << 6

    next_id = 0

    def __init__(self, days=0, on_hour=None, on_minute=None, off_hour=None, off_minute=None, target=None, zone=None):
        self.id = Rule.next_id
        Rule.next_id += 1
        self.days = days
        self.on_hour = on_hour
        self.on_minute = on_minute
        self.off_hour = off_hour
        self.off_minute = off_minute
        self.target = target
        self.zone = zone

    def read_dict(self, data):
        if 'id' in data:
            self.id = data['id']
        else:
            self.id = Rule.next_id
            Rule.next_id += 1
        self.days = data['days']
        self.on_hour = data['on_hour']
        self.on_minute = data['on_minute']
        self.off_hour = data['off_hour']
        self.off_minute = data['off_minute']
        self.target = data['target']
        self.zone = zone_by_name(data['zone'])

    def as_dict(self):
        return {"id": self.id,
                "days": self.days,
                "on_hour": self.on_hour,
                "on_minute": self.on_minute,
                "off_hour": self.off_hour,
                "off_minute": self.off_minute,
                "target": self.target,
                "zone": str(self.zone)}

    def active(self, time=None):
        """
        Return true if this rule is active at the given time (the current
        time is used if time=None).
        """
        if time is None:
            time = datetime.datetime.now()
        if (self.days & (1 << time.weekday())) == 0:
            return False

        if self.on_hour > time.hour or self.off_hour < time.hour:
            return False

        on_ok = self.on_hour < time.hour or self.on_minute <= time.minute
        off_ok = self.off_hour > time.hour or self.off_minute > time.minute

        return on_ok and off_ok

    def __str__(self):
        return '%d: %d %d:%d %d:%d %f %s' % (self.id, self.days, self.on_hour, self.on_minute, self.off_hour, self.off_minute, self.target, self.zone)

    def __eq__(self, other):
        if other is None:
            return False

        on_same = self.on_hour == other.on_hour and self.on_minute == other.on_minute
        off_same = self.off_hour == other.off_hour and self.off_minute == other.off_minute

        return self.id == other.id and self.days == other.days and on_same and off_same and self.zone == other.zone and self.target == other.target

    def __ne__(self, other):
        return not self.__eq__(other)


class State:
    """State of the heating system"""
    def __init__(self):
        global args

        # Whether the whole thing is enabled (i.e. checking temperatures and maybe heating)
        self.heating_enabled = False
        # Whether each zone is enabled
        self.zone_enabled = {}
        # Target for each zone
        self.target = {}
        # Whether the boiler is on
        self.boiler_on = False
        # Temperatures in each zone
        self.temperatures = {}
        self.rules = []

        self.mutex = threading.Lock()


    # Set methods for use by the server

    def set_heating_enabled(self, enabled):
        changed = False
        with self.mutex:
            if enabled != self.heating_enabled:
                self.heating_enabled = enabled
                changed = True
        if changed:
            server.send(self.as_dict("heating_enabled"))
            request_update()

    def set_zone_enabled(self, zone, enabled):
        changed = False
        with self.mutex:
            if not zone in self.zone_enabled:
                self.zone_enabled[zone] = False
            if self.zone_enabled[zone] != enabled:
                self.zone_enabled[zone] = enabled
                changed = True
        if changed:
            server.send(self.as_dict("zone_enabled"))
            request_update()

    def set_target(self, zone, target):
        changed = False
        with self.mutex:
            if abs(target - self.target[zone]) > 1e-6:
                self.target[zone] = target
                changed = True
        if changed:
            server.send(self.as_dict("target"))
            request_update()

    def set_boiler_on(self, on):
        changed = False
        with self.mutex:
            if on != self.boiler_on:
                self.boiler_on = on
                if have_gpio:
                    RPi.GPIO.output(BOILER_GPIO, self.boiler_on)
                changed = True
        if changed:
            server.send(self.as_dict("boiler_on"))

    def set_temperatures(self, zone, temperatures):
        with self.mutex:
            self.temperatures[zone] = temperatures
        server.send(self.as_dict("temperatures"))

    def add_temperature(self, zone, t):
        with self.mutex:
            if not zone in self.temperatures:
                self.temperatures[zone] = []
            self.temperatures[zone].append(t)
            if len(self.temperatures[zone]) > MEMORY_LOG_MINUTES:
                state.temperatures[zone].pop(0)
        server.send(self.as_dict("temperatures"))

    def set_rules(self, r):
        assert(type(r) is list)
        changed = False
        with self.mutex:
            if self.rules != r:
                self.rules = r
                changed = True
        if changed:
            server.send(self.as_dict("rules"))


    # Get methods for use by the server

    def get_heating_enabled(self):
        with self.mutex:
            return self.heating_enabled

    def get_zone_enabled(self, zone):
        with self.mutex:
            if not zone in self.zone_enabled:
                self.zone_enabled[zone] = False
            return self.zone_enabled[zone]

    def get_target(self, zone):
        with self.mutex:
            if not zone in self.target:
                self.target[zone] = DEFAULT_TARGET
            return self.target[zone]

    def get_boiler_on(self):
        with self.mutex:
            return self.boiler_on

    def get_current_temperature(self, zone):
        t = 0.0
        with self.mutex:
            if not zone in self.temperatures:
                self.temperatures[zone] = []
            if len(self.temperatures[zone]) > 0:
                t = self.temperatures[zone][-1]
        return t

    def get_active_rules(self):
        with self.mutex:
            return [r for r in self.rules if r.active()]


    # Misc

    def as_dict(self, key=None, all_temperatures=True):
        """
        Return some or all state as dict; all state is returned
        if key is None.
        """
        zone_enabled = []
        for k, v in self.zone_enabled.iteritems():
            zone_enabled.append({"zone": k.name, "zone_enabled": v})

        target = []
        for k, v in self.target.iteritems():
            target.append({"zone": k.name, "target": v})

        temperatures = []
        for k, v in self.temperatures.iteritems():
            if all_temperatures:
                temperatures.append({"zone": k.name, "temperatures": v})
            elif len(v) > 0:
                temperatures.append({"zone": k.name, "temperatures": [v[-1]]})

        rules = []
        for r in self.rules:
            rules.append(r.as_dict())

        all = {"heating_enabled": self.heating_enabled,
               "zone_enabled": zone_enabled,
               "target": target,
               "boiler_on": self.boiler_on,
               "temperatures": temperatures,
               "rules": rules}

        if key is not None:
            out = { key: all[key] }
        else:
            out = all

        return out

    def set_from_dict(self, c):
        """Set up this object from a dict"""
        if 'heating_enabled' in c:
            self.set_heating_enabled(c['heating_enabled'])
        if 'zone_enabled' in c:
            for z in c['zone_enabled']:
                self.set_zone_enabled(zone_by_name(z['zone']), z['zone_enabled'])
        if 'target' in c:
            for z in c['target']:
                self.set_target(zone_by_name(z['zone']), z['target'])
        if 'boiler_on' in c:
            self.set_boiler_on(c['boiler_on'])
        if 'temperatures' in c:
            for z in c['temperatures']:
                self.set_temperatures(zone_by_name(z['zone']), z['temperatures'])
        if 'rules' in c:
            rules = []
            for dr in c['rules']:
                r = Rule()
                r.read_dict(dr)
                rules.append(r)
            self.set_rules(rules)

def setup():
    global args
    global have_gpio
    global write_logs

    if have_gpio:
        RPi.GPIO.setwarnings(False)
        RPi.GPIO.setmode(RPi.GPIO.BCM)
        RPi.GPIO.setup(BOILER_GPIO, RPi.GPIO.OUT)
    else:
        util.warning('GPIO library not found; running without GPIO')

    try:
        os.makedirs(args.log_directory)
    except OSError as e:
        if e.errno != 17:
            util.warning('could not create log directory `%s\'; logging disabled' % args.log_directory)
            write_logs = False


def update():
    global state

    # Apply auto-off
    time = datetime.datetime.now()
    if time.minute == 0 and time.hour in AUTO_OFF_HOURS and state.get_heating_enabled():
        state.set_heating_enabled(False)
        util.verbose('turned off automatically at %d:%02d' % (time.hour, time.minute))

    # Work out whether each zone is enabled and what its temperature should be

    heating_enabled = False
    zone_enabled = {}
    target = {}

    for z in zones():
        zone_enabled[z] = False
        target[z] = DEFAULT_TARGET

    rules = state.get_active_rules()
    if len(rules) > 0:
        # If there are active rules they dictate everything
        for r in state.get_active_rules():
            heating_enabled = True
            zone_enabled[r.zone] = True
            target[r.zone] = r.target
    else:
        # Use current state as there are no active rules
        heating_enabled = state.get_heating_enabled()
        for z in zones():
            zone_enabled[z] = state.get_zone_enabled(z)
            target[z] = state.get_target(z)

    note = ''

    # Zone radiators on or off
    for z in zones():
        try:
            if zone_enabled[z]:
                t = state.get_current_temperature(z)
                if t > (target[z] + HYSTERESIS):
                    z.set_radiator_on(False)
                    note += '%s off ' % z
                elif t < (target[z] - HYSTERESIS):
                    z.set_radiator_on(True)
                    note += '%s on ' % z
            else:
                z.set_radiator_on(False)
        except (socket.error, util.Error) as e:
            util.warning('could not instruct zone %s (%s)' % (z, e))
            pass

    heat_required = False
    for z in zones():
        if z.radiator_on:
            heat_required = True

    # Then turn the boiler on or off
    state.set_boiler_on(heat_required and heating_enabled)

def broadcast_listen():
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("0.0.0.0", BROADCAST_PORT))
    while True:
        data, addr = sock.recvfrom(64)
        if data.startswith('Hello heating'):
            mac = data[14:]
            try:
                dynamic_zones_mutex.acquire()
                got = False
                for z in dynamic_zones:
                    if z.mac == mac:
                        got = True
                if not got:
                    util.verbose('Adding dynamic zone at %s %s' % (addr[0], mac))
                    dynamic_zones.append(ESP8266Zone(addr[0], mac))
            finally:
                dynamic_zones_mutex.release()

def check():
    global state
    global stop
    global update_condition
    while not stop:
        try:
            update()
        except Exception as e:
            traceback.print_exc()
        update_condition.acquire()
        update_condition.wait(CHECK_INTERVAL)
        update_condition.release()

def log():
    global state
    global stop
    global args

    while not stop:
        log_file = os.path.join(args.log_directory, time.strftime("%d-%m-%Y.log"))

        for z in zones():
            try:
                temp = z.get_temperature()

                if write_logs:
                    f = open(log_file, 'a')
                    print>>f,'%s %f %f %d %d' % (time.strftime("%H:%M:%S"), temp, state.get_target(z), state.get_boiler_on(), state.get_heating_enabled())
                    f.close()

                state.add_temperature(z, temp)
            except Exception as e:
                traceback.print_exc(file=sys.stdout)
                util.warning('could not get temperature from %s (%s)' % (z, e))

        time.sleep(args.log_interval)

def test():
    rule = Rule(Rule.MONDAY, 9, 30, 15, 30)
    assert(rule.active(datetime.datetime(2014, 11, 17, 8, 45)) == False)
    assert(rule.active(datetime.datetime(2014, 11, 17, 9, 29)) == False)
    assert(rule.active(datetime.datetime(2014, 11, 17, 9, 31)) == True)
    assert(rule.active(datetime.datetime(2014, 11, 17, 10, 31)) == True)
    assert(rule.active(datetime.datetime(2014, 11, 17, 15, 25)) == True)
    assert(rule.active(datetime.datetime(2014, 11, 17, 15, 25)) == True)
    assert(rule.active(datetime.datetime(2014, 11, 17, 15, 35)) == False)
    assert(rule.active(datetime.datetime(2014, 11, 17, 18, 15)) == False)
    assert(rule.active(datetime.datetime(2014, 11, 18, 15, 25)) == False)

    rule = Rule(Rule.WEDNESDAY, 7, 30, 8, 30)
    assert(rule.active(datetime.datetime(2014, 11, 19, 8, 20)) == True)

def handler(json):
    if json['type'] == 'ping':
        server.send({'type': 'pong'})
    elif json['type'] == 'send_basic':
        global state
        server.send(state.as_dict(all_temperatures=False))
    elif json['type'] == 'send_all':
        global state
        server.send(state.as_dict())
    elif json['type'] == 'change':
        state.set_from_dict(json)

parser = argparse.ArgumentParser()
parser.add_argument('-p', '--port', help='port to bind to', type=int, default=80)
parser.add_argument('-i', '--log-interval', help='interval in seconds at which to log temperatures', type=int, default=60)
parser.add_argument('-l', '--log-directory', help='directory to log temperatures to', type=str, default='/var/log/toast')
args = parser.parse_args()

if len(sys.argv) > 1 and sys.argv[1] == 'test':
    test()
else:
    setup()

    server = json_server.Server(args.port)
    server.handler = handler
    server.start()

    state = State()

    check_thread = threading.Thread(target=check)
    check_thread.start()

    log_thread = threading.Thread(target=log)
    log_thread.start()

    broadcast_listen_thread = threading.Thread(target=broadcast_listen)
    broadcast_listen_thread.start()

    while True:
        time.sleep(60)
