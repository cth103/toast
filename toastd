#!/usr/bin/python
#
#    Copyright (C) 2014-2015 Carl Hetherington <cth@carlh.net>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

have_gpio = True
try:
    import RPi.GPIO
except:
    have_gpio = False

import BaseHTTPServer
import threading
import json
import time
import os
import sys
import datetime
import socket
import argparse
import urlparse
import traceback

import json_server
import util

# GPIO pin of heating relay
HEATING = 2
# Hysteresis in degrees
HYSTERESIS = 0.2
# Interval in seconds to check state and update hardware
CHECK_INTERVAL = 1
# Minutes to keep temperatures in memory
MEMORY_LOG_MINUTES = 60 * 24 * 7
# Auto-off start hour
AUTO_OFF_START = 0
# Auto-off end hour
AUTO_OFF_END = 6
# Auto-off check interval (minutes)
AUTO_OFF_INTERVAL = 30

class Zone:
    def __init__(self, name, ip, port=9142):
        self.name = name
        self.ip = ip
        self.port = port
        self.on = False

    def __str__(self):
        return self.name

    def __eq__(self, other):
        if other is None:
            return False

        return self.name == other.name

    def __hash__(self):
        return hash(self.name)

    def set_on(self, on):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.ip, self.port))
        util.send_json(s, {'type': 'set', 'on': on})
        self.on = on

    def get_temperature(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.ip, self.port))
        util.send_json(s, {'type': 'get'})
        return util.receive_json(s)['temperature']

ZONES = []
ZONES.append(Zone('Sitting room', 'localhost'))
ZONES.append(Zone('Bathroom', 'zone1'))

# True to stop all threads
stop = False
# Server which talks to clients
server = None
# True to write logs, false if not
write_logs = True
current_rule = None

def zone_by_name(name):
    for z in ZONES:
        if z.name == name:
            return z

    return None

# Rule to specify a target to aim for during a particular time range
class Rule:

    MONDAY = 1 << 0
    TUESDAY = 1 << 1
    WEDNESDAY = 1 << 2
    THURSDAY = 1 << 3
    FRIDAY = 1 << 4
    SATURDAY = 1 << 5
    SUNDAY = 1 << 6

    next_id = 0

    def __init__(self, days=0, on_hour=None, on_minute=None, off_hour=None, off_minute=None, target=None, zone=None):
        self.id = Rule.next_id
        Rule.next_id += 1
        self.days = days
        self.on_hour = on_hour
        self.on_minute = on_minute
        self.off_hour = off_hour
        self.off_minute = off_minute
        self.target = target
        self.zone = zone

    def read_dict(self, data):
        if 'id' in data:
            self.id = data['id']
        else:
            self.id = Rule.next_id
            Rule.next_id += 1
        self.days = data['days']
        self.on_hour = data['on_hour']
        self.on_minute = data['on_minute']
        self.off_hour = data['off_hour']
        self.off_minute = data['off_minute']
        self.target = data['target']
        self.zone = zone_by_name(data['zone'])

    def as_dict(self):
        return {"id": self.id,
                "days": self.days,
                "on_hour": self.on_hour,
                "on_minute": self.on_minute,
                "off_hour": self.off_hour,
                "off_minute": self.off_minute,
                "target": self.target,
                "zone": str(self.zone)}

    def active(self, time=None):
        if time is None:
            time = datetime.datetime.now()
        if (self.days & (1 << time.weekday())) == 0:
            return False

        if self.on_hour > time.hour or self.off_hour < time.hour:
            return False

        on_ok = self.on_hour < time.hour or self.on_minute <= time.minute
        off_ok = self.off_hour > time.hour or self.off_minute > time.minute

        return on_ok and off_ok

    def __str__(self):
        return '%d: %d %d:%d %d:%d %f %s' % (self.id, self.days, self.on_hour, self.on_minute, self.off_hour, self.off_minute, self.target, self.zone)

    def __eq__(self, other):
        if other is None:
            return False

        on_same = self.on_hour == other.on_hour and self.on_minute == other.on_minute
        off_same = self.off_hour == other.off_hour and self.off_minute == other.off_minute

        return self.id == other.id and self.days == other.days and on_same and off_same and self.zone == other.zone

    def __ne__(self, other):
        return not self.__eq__(other)


class State:
    """State of the heating system"""
    def __init__(self):
        global args

        # Whether the boiler is on
        self.on = False
        # Whether the whole thing is enabled (i.e. checking temperatures and maybe heating)
        self.enabled = False
        self.rules = []
        # Temperatures in each zone
        self.temperatures = {}
        # Target for each zone
        self.target = {}

        for z in ZONES:
            self.temperatures[z] = []
            self.target[z] = 21

        self.mutex = threading.Lock()


    # Set methods for use by the server

    def set_target(self, zone, target):
        changed = False
        with self.mutex:
            if abs(target - self.target[zone]) > 1e-6:
                self.target[zone] = target
                changed = True
        if changed:
            server.send(self.as_dict("target"))

    def set_on(self, on):
        changed = False
        with self.mutex:
            if on != self.on:
                self.on = on
                if have_gpio:
                    RPi.GPIO.output(HEATING, self.on)
                changed = True
        if changed:
            server.send(self.as_dict("on"))

    def set_enabled(self, enabled):
        changed = False
        with self.mutex:
            if enabled != self.enabled:
                self.enabled = enabled
                changed = True
        if changed:
            server.send(self.as_dict("enabled"))

    def set_temperatures(self, zone, temperatures):
        with self.mutex:
            self.temperatures[zone] = temperatures
        server.send(self.as_dict("temperatures"))

    def add_temperature(self, zone, t):
        with self.mutex:
            self.temperatures[zone].append(t)
            if len(self.temperatures[zone]) > MEMORY_LOG_MINUTES:
                state.temperatures[zone].pop(0)
        server.send(self.as_dict("temperatures"))

    def set_rules(self, r):
        assert(type(r) is list)
        changed = False
        with self.mutex:
            if self.rules != r:
                self.rules = r
                changed = True
        if changed:
            server.send(self.as_dict("rules"))

    # Get methods for use by the server

    def get_current_temperature(self, zone):
        t = 0.0
        with self.mutex:
            if len(self.temperatures[zone]) > 0:
                t = self.temperatures[zone][-1]
        return t

    def get_target(self, zone):
        with self.mutex:
            return self.target[zone]

    def get_active_rule(self):
        with self.mutex:
            active_rules = [r for r in self.rules if r.active()]
            # XXX: multiple active rules?
            if len(active_rules) > 0:
                return active_rules[0]

            return None

    def get_enabled(self):
        with self.mutex:
            return self.enabled

    def get_on(self):
        with self.mutex:
            return self.on

    # Misc

    def as_dict(self, key=None):
        rules = []
        for r in self.rules:
            rules.append(r.as_dict())

        all = {"temperatures": self.temperatures,
               "target": self.target,
               "on": self.on,
               "enabled": self.enabled,
               "rules": rules}

        if key is not None:
            out = { key: all[key] }
        else:
            out = all

        return out

    def set_from_dict(self, c):
        if 'target' in c:
            for z in ZONES:
                self.set_target(z, c['target'][z.name])
        if 'on' in c:
            self.set_on(c['on'])
        if 'enabled' in c:
            self.set_enabled(c['enabled'])
        if 'temperatures' in c:
            for z in ZONES:
                self.set_temperatures(z, c['temperatures'][z.name])
        if 'rules' in c:
            rules = []
            for dr in c['rules']:
                r = Rule()
                r.read_dict(dr)
                rules.append(r)
            self.set_rules(rules)


def setup():
    global args
    global have_gpio
    global write_logs

    if have_gpio:
        RPi.GPIO.setwarnings(False)
        RPi.GPIO.setmode(RPi.GPIO.BCM)
        RPi.GPIO.setup(HEATING, RPi.GPIO.OUT)
    else:
        util.warning('GPIO library not found; running without GPIO')

    try:
        os.makedirs(args.log_directory)
    except OSError as e:
        if e.errno != 17:
            util.warning('could not create log directory `%s\'; logging disabled' % args.log_directory)
            write_logs = False


def update():
    global state
    global current_rule

    # Apply rules first
    active_rule = state.get_active_rule()
    if active_rule != current_rule:
        state.set_target(active_rule.zone, active_rule.target)
        state.set_enabled(active_rule is not None)
        current_rule = active_rule

    # Apply auto-off
    time = datetime.datetime.now()
    if time.hour >= AUTO_OFF_START and time.hour <= AUTO_OFF_END and (time.minute % AUTO_OFF_INTERVAL) == 0 and state.enabled:
        state.set_enabled(False)
        util.verbose('Turned off automatically at %d:%02d' % (time.hour, time.minute))

    note = ''

    # Zone radiators on or off
    for z in ZONES:
        try:
            t = state.get_current_temperature(z)
            if t > (state.get_target(z) + HYSTERESIS):
                z.set_on(False)
                note += '%s off ' % z
            elif t < (state.get_target(z) - HYSTERESIS):
                z.set_on(True)
                note += '%s on ' % z
        except (socket.error, util.Error) as e:
            util.warning('could not instruct zone %s (%s)' % (z, e))

    # Now check zone radiator state and decide whether we need heat
    heat_required = False
    for z in ZONES:
        if z.on:
            heat_required = True

    # Then turn the boiler on or off
    state.set_on(heat_required and state.get_enabled())
    note += 'and boiler %d (heat_required %d)' % (heat_required and state.get_enabled(), heat_required)
    util.verbose(note)

def check():
    global state
    global stop
    while not stop:
        update()
        time.sleep(CHECK_INTERVAL)

def log():
    global state
    global stop
    global args

    while not stop:
        log_file = os.path.join(args.log_directory, time.strftime("%d-%m-%Y.log"))

        for z in ZONES:
            try:
                temp = z.get_temperature()

                if write_logs:
                    f = open(log_file, 'a')
                    print>>f,'%s %f %f %d %d' % (time.strftime("%H:%M:%S"), temp, state.get_target(z), state.get_on(), state.get_enabled())
                    f.close()

                state.add_temperature(z, temp)
            except Exception as e:
                util.warning('could not get temperature from %s' % z)

        time.sleep(args.log_interval)

def test():
    rule = Rule(Rule.MONDAY, 9, 30, 15, 30)
    assert(rule.active(datetime.datetime(2014, 11, 17, 8, 45)) == False)
    assert(rule.active(datetime.datetime(2014, 11, 17, 9, 29)) == False)
    assert(rule.active(datetime.datetime(2014, 11, 17, 9, 31)) == True)
    assert(rule.active(datetime.datetime(2014, 11, 17, 10, 31)) == True)
    assert(rule.active(datetime.datetime(2014, 11, 17, 15, 25)) == True)
    assert(rule.active(datetime.datetime(2014, 11, 17, 15, 25)) == True)
    assert(rule.active(datetime.datetime(2014, 11, 17, 15, 35)) == False)
    assert(rule.active(datetime.datetime(2014, 11, 17, 18, 15)) == False)
    assert(rule.active(datetime.datetime(2014, 11, 18, 15, 25)) == False)

    rule = Rule(Rule.WEDNESDAY, 7, 30, 8, 30)
    assert(rule.active(datetime.datetime(2014, 11, 19, 8, 20)) == True)

def handler(json):
    if json['type'] == 'ping':
        server.send({'type': 'pong'})
    elif json['type'] == 'send_all':
        global state
        server.send(state.as_dict())
    elif json['type'] == 'change':
        state.set_from_dict(json)

parser = argparse.ArgumentParser()
parser.add_argument('-p', '--port', help='port to bind to', type=int, default=80)
parser.add_argument('-i', '--log-interval', help='interval in seconds at which to log temperatures', type=int, default=60)
parser.add_argument('-l', '--log-directory', help='directory to log temperatures to', type=str, default='/var/log/toast')
args = parser.parse_args()

if len(sys.argv) > 1 and sys.argv[1] == 'test':
    test()
else:
    setup()

    server = json_server.Server(args.port)
    server.handler = handler
    server.start()

    state = State()

    check_thread = threading.Thread(target=check)
    check_thread.start()

    log_thread = threading.Thread(target=log)
    log_thread.start()

    while True:
        time.sleep(60)
